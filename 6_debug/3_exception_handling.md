# Implement exception handling in C# console applications


## Examine exceptions and the exception handling process
- Runtime errors are managed using exceptions
- Exceptions provide a structured, uniform, and type-safe way of handling both system level and application-level error conditions
- Systems are generated by .NET runtime or by the code in an application

### Common Exception Handling Scenarios
- User input (wrong format or out of range)
- Data processing and computations (divide by zero, cast to unsupported type, assign value out of range)
- File input/output operations
- Database operations (lost connection, syntax)
- Network communications (timeout, lost connection)
- Other external resources (Web services, REST APIs, third-party libraries)

### Exception handling keywords, code blocks, and patterns
- Exception handling is implemented using ```try```, ```catch```, and ```finally``` keywords.
- Components
  - ```try``` code block contains the guarded code that may cause an exception
  - ```catch``` code block contains the code that's executed when an exception is caught; it can handle it, log it, or ignore it
  - ```finally``` code block contains code that executes whether an exception occurs or not; used to clean up resources allocated in a ```try``` block
        ```csharp
        try
        {   
            // try code block - code that may generate an exception
        }
        catch
        {   
            // catch code block - code to handle an exception
        }
        finally
        {   
            // finally code block - code to clean up resources
        }
        ```

- **Note**: Can generate an exception object by using the ```throw``` keyword.

### How are exceptions represented in code?
- Exceptions in code are objects or an instance of a class
- .NET class library provides exceptions classes that are accessed in code just like other .NET classes
- Exceptions are types, represented by classes that are all ultimately derived from ```System.Exception```
- An exception classes that's derived from ```Exception``` includes information that identifies the type of exception and contains properties that provide details about the exception
- A runtime instance of a class is generally referred to as an object, so exceptions are often referred to as **exception objects**

### Exception Handling Process
- Consider the following code sample that includes a ```try-finally``` pattern nested inside a ```try-catch``` pattern:
    ```csharp
    try
    {
        // Step 1: code execution begins
        try
        {
            // Step 2: an exception occurs here
        }
        finally
        {
            // Step 4: the system executes the finally code block associated with the try statement where the exception occurred
        }

    }
    catch // Step 3: the system finds a catch clause that can handle the exception
    {   
        // Step 5: the system transfers control to the first line of the catch code block
    }
    ```
    1. Execution begins in the code block of the outer try statement.
    2. An exception is thrown in the code block of the inner try statement.
    3. The runtime finds the catch clause associated with the outer try statement.
    4. Before the runtime transfers control to the first line of the catch code block, it executes the finally clause associated with the inner try statement.
    5. The runtime then transfers control to the first line of the catch code block and executes the code that handles the exception.

### Exception handling and the call stack
- The call stack is like a tower of blocks
- When the application starts running in the debugger, the entry point to the application is the first layer added to the call stack
- Each time a method calls another method, the new method is added to the top of the stack
- When the code exits out of a method, the method is removed from the call stack
- **Call stack unwinding** is the process that the .NET runtime uses when a C# program encounters an error

### Recap
- Common scenarios that may require exception handling include user input, data processing, file I/O operations, database operations, and network communication.
- Exception handling in C# is implemented using try, catch, and finally keywords. Each keyword has an associated code block that serves a specific purpose.
- Exceptions are represented as types and derived from the System.Exception class in .NET. Exceptions contain information that identifies the type of exception, and properties that provide additional details.
- When an exception occurs, the .NET runtime searches for the nearest catch clause that can handle it. The search starts with the method where the exception was thrown, and moves down the call stack if necessary.

## Examine compiler-generated exceptions

- ```ArrayTypeMismatchException```: Thrown when an array can't store a given element because the actual type of the element is incompatible with the actual type of the array.
- ```DivideByZeroException```: Thrown when an attempt is made to divide an integral value by zero.
- ```FormatException```: Thrown when the format of an argument is invalid.
- ```IndexOutOfRangeException```: Thrown when an attempt is made to index an array when the index is less than zero or outside the bounds of the array.
- ```InvalidCastException```: Thrown when an explicit conversion from a base type to an interface or to a derived type fails at runtime.
- ```NullReferenceException```: Thrown when an attempt is made to reference an object whose value is null.
- ```OverflowException```: Thrown when an arithmetic operation in a checked context overflows.

### Code samples for compiler-generated exceptions
```csharp
// ArrayTypeMismatchException
string[] names = { "Dog", "Cat", "Fish" };
Object[] objs = (Object[])names;

Object obj = (Object)13;
objs[2] = obj; // ArrayTypeMismatchException occurs


// DivideByZeroException
int number1 = 3000;
int number2 = 0;
Console.WriteLine(number1 / number2); // DivideByZeroException occurs


// FormatException
int valueEntered;
string userValue = "two";
valueEntered = int.Parse(userValue); // FormatException occurs


// IndexOutOfRangeException
int[] values1 = { 3, 6, 9, 12, 15, 18, 21 };
int[] values2 = new int[6];

values2[values1.Length - 1] = values1[values1.Length - 1]; // IndexOutOfRangeException occurs


// InvalidCastException
object obj = "This is a string";
int num = (int)obj;


// NullReferenceException
int[] values = null;
for (int i = 0; i <= 9; i++)
    values[i] = i * 2;

    string? lowCaseString = null;
Console.WriteLine(lowCaseString.ToUpper());


// OverflowException
decimal x = 400;
byte i;

i = (byte)x; // OverflowException occurs
Console.WriteLine(i);
```

## Exercise - Implement try-catch exception handling
- Implement a try/catch block to handle the divide by zero exception in the following code:
    ```csharp
    double float1 = 3000.0;
    double float2 = 0.0;
    int number1 = 3000;
    int number2 = 0;

    Console.WriteLine(float1 / float2);
    Console.WriteLine(number1 / number2);
    Console.WriteLine("Exit program");
    ```

- Solution:
    ```csharp
    double float1 = 3000.0;
    double float2 = 0.0;
    int number1 = 3000;
    int number2 = 0;

    try
    {
        Console.WriteLine(float1 / float2);
        Console.WriteLine(number1 / number2);
    }
    catch
    {
        Console.WriteLine("An exception has been caught.");
    }

    Console.WriteLine("Exit program");
    ```

## Exercise: Complete a challenge activity for try-catch
- Implement exception handling in the ```Process1()``` method
    ```csharp
    try
    {
        Process1();
    }
    catch
    {
        Console.WriteLine("An exception has occurred");
    }

    Console.WriteLine("Exit program");

    static void Process1()
    {
        WriteMessage();
    }

    static void WriteMessage()
    {
        double float1 = 3000.0;
        double float2 = 0.0;
        int number1 = 3000;
        int number2 = 0;

        Console.WriteLine(float1 / float2);
        Console.WriteLine(number1 / number2);
    }
    ```

- Solution
    ```csharp
    try
    {
        Process1();
    }
    catch
    {
        Console.WriteLine("An exception has occurred");
    }

    Console.WriteLine("Exit program");

    static void Process1()
    {
        try
        {
            WriteMessage();
        }
        catch
        {
            Console.WriteLine("Exception caught in Process1");
        }    
    }

    static void WriteMessage()
    {
        double float1 = 3000.0;
        double float2 = 0.0;
        int number1 = 3000;
        int number2 = 0;

        Console.WriteLine(float1 / float2);
        Console.WriteLine(number1 / number2);
    }
    ```

# Exercise - Catch specific exception types
- ```System.Exception``` is the base class that all derived exception types inherit from
- Each exception type inherits from the base class through a specific class hierarchy
- The class hierarchy for the ```InvalidCastException``` is as follows:
    ```
    Object
        Exception
            SystemException
                InvalidCastException
    ```

- Most of the exception classes that inherit from ```Exception``` do not add any functionality
- Examining the properties of the ```Exception``` class enables you to understand most exceptions
- ```Exception``` class properties:
    - **Data**: The Data property holds arbitrary data in key-value pairs.
    - **HelpLink**: The HelpLink property can be used to hold a URL (or URN) to a help file that provides extensive information about the cause of an exception.
    - **HResult**: The HResult property can be used to access to a coded numerical value that's assigned to a specific exception.
    - **InnerException**: The InnerException property can be used to create and preserve a series of exceptions during exception handling.
    - **Message**: The Message property provides details about the cause of an exception.
    - **Source**: The Source property can be used to access the name of the application or the object that causes the error.
    - **StackTrace**: The StackTrace property contains a stack trace that can be used to determine where an error occurred.
    - **TargetSite**: The TargetSite property can be used to get the method that throws the current exception.

- Catch a specific exception type to handle (```DivideByZeroException```):
    ```csharp
    static void Process1()
    {
        try
        {
            WriteMessage();
        }
        catch (DivideByZeroException ex)
        {
            Console.WriteLine($"Exception caught in Process1: {ex.Message}");
        }
    }
    ```

- Catch multiple specific exceptions:
    ```csharp
    // inputValues is used to store numeric values entered by a user
    string[] inputValues = new string[]{"three", "9999999999", "0", "2" };

    foreach (string inputValue in inputValues)
    {
        int numValue = 0;
        try
        {
            numValue = int.Parse(inputValue);
        }
        catch (FormatException)
        {
            Console.WriteLine("Invalid readResult. Please enter a valid number.");
        }
        catch (OverflowException)
        {
            Console.WriteLine("The number you entered is too large or too small.");
        }
        catch(Exception ex)
        {
            Console.WriteLine(ex.Message);
        }
    }
    ```

## Exercise - Complete a challenge activity to catch specific exceptions
- Update the code so that each error message is displayed to the console that the exception type occurs.
- The program output should be:
    ```
    Error: The number is too large to be represented as an integer. Arithmetic operation resulted in an overflow.
    Error: The reference is null. Object reference not set to an instance of an object.
    Error: Index out of range. Index was outside the bounds of the array.
    Error: Cannot divide by zero. Attempted to divide by zero.
    Exiting program.
    ```

- Starter Code:
    ```csharp
    try
    {
        int num1 = int.MaxValue;
        int num2 = int.MaxValue;
        int result = num1 + num2;
        Console.WriteLine("Result: " + result);

        string str = null;
        int length = str.Length;
        Console.WriteLine("String Length: " + length);

        int[] numbers = new int[5];
        numbers[5] = 10;
        Console.WriteLine("Number at index 5: " + numbers[5]);

        int num3 = 10;
        int num4 = 0;
        int result2 = num3 / num4;
        Console.WriteLine("Result: " + result2);
    }
    catch (OverflowException ex)
    {
        Console.WriteLine("Error: The number is too large to be represented as an integer." + ex.Message);
    }
    catch (NullReferenceException ex)
    {
        Console.WriteLine("Error: The reference is null." + ex.Message);
    }
    catch (IndexOutOfRangeException ex)
    {
        Console.WriteLine("Error: Index out of range." + ex.Message);
    }
    catch (DivideByZeroException ex)
    {
        Console.WriteLine("Error: Cannot divide by zero." + ex.Message);
    }

    Console.WriteLine("Exiting program.");
    ```

- Solution:
    ```csharp
    try
    {
        checked
        {
            int num1 = int.MaxValue;
            int num2 = int.MaxValue;
            int result = num1 + num2;
            Console.WriteLine("Result: " + result);
        }
    }
    catch (OverflowException ex)
    {
        Console.WriteLine("Error: The number is too large to be represented as an integer. " + ex.Message);
    }


    try
    {
        string str = null;
        int length = str.Length;
        Console.WriteLine("String Length: " + length);
    }
    catch (NullReferenceException ex)
    {
        Console.WriteLine("Error: The reference is null. " + ex.Message);
    }


    try
    {
        int[] numbers = new int[5];
        numbers[5] = 10;
        Console.WriteLine("Number at index 5: " + numbers[5]);
    }
    catch (IndexOutOfRangeException ex)
    {
        Console.WriteLine("Error: Index out of range. " + ex.Message);
    }


    try
    {
        int num3 = 10;
        int num4 = 0;
        int result2 = num3 / num4;
        Console.WriteLine("Result: " + result2);
    }
    catch (DivideByZeroException ex)
    {
        Console.WriteLine("Error: Cannot divide by zero. " + ex.Message);
    }

    Console.WriteLine("Exiting program.");
    ```